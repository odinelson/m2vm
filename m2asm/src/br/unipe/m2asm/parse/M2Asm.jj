/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. M2Asm.jj */
/*@egen*//**
 * Segunda vers\u00c3\u00a3o do Assembler para M2, agora com JavaCC
 * Esta vers\u00c3\u00a3o trata corretamente as quebras de linha
 * A inten\u00c3\u00a7\u00c3\u00a3o \u00c3\u00a9 que a gram\u00c3\u00a1tica seja m\u00c3\u00adnima, e certas verifica\u00c3\u00a7\u00c3\u00b5es
 * (por exemplo, o n\u00c3\u00bamero/tipo de argumentos corretos para cada opcode)
 * sejam feitas na \u00c3\ufffdrvore de Sintaxe Abstrata. 
 *
 * @author Odilon
 * TODO Finalizar
 */options{  JDK_VERSION = "1.5";  STATIC = false;
                           
                 
               
                               
                                                           }PARSER_BEGIN(M2AsmParser)package br.unipe.m2asm.parse;

public class M2AsmParser/*@bgen(jjtree)*/implements M2AsmParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTM2AsmParserState jjtree = new JJTM2AsmParserState();

/*@egen*/}PARSER_END(M2AsmParser)
SKIP :
{
  " "
| "\t"
}
TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    ( "-" )? < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])?     >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
| < CHAR_LITERAL : "'" ~[] "'" >
| < STR_LITERAL : "\"" (~["\""])* "\"" >
// gambiarra meio feia, mas util:
// um token newline \u00c3\u00a9 composto de um comentario opcional seguido de quebra de linha
// isso possibilita tratar coment\u00c3\u00a1rios como quebras de linha, e simplifica a gram\u00c3\u00a1tica
// o \u00c3\u00banico problema dessa abordagem \u00c3\u00a9 que o montador falha se o programa terminar com um coment\u00c3\u00a1rio
// sem quebra de linha ap\u00c3\u00b3s... 
| < NEWLINE: ( ";" (~[ "\n", "\r" ])* )? ["\r", "\n"] | "\r\n" | "\n\r" >}
TOKEN : /* RESERVED WORDS */
{
  //  opcodes
  < NOP : ("NOP" | "NOP") >  | < HALT : ("HALT" | "halt") >
  |
  < INC : ("INC" | "inc") >  | < DEC : ("DEC" | "dec") >
  |
  < ADD : ("ADD" | "add") >  | < SUB : ("SUB" | "sub") >
  |
  < MUL : ("MUL" | "mul") >  | < DIV : ("DIV" | "div") >
  |
  < NEG : ("NEG" | "neg") >
  |
  < AND : ("AND" | "and") >  | < OR : ("OR" | "or") >
  |
  < XOR : ("XOR" | "xor") >  | < NOT : ("NOT" | "not") >
  |
  < SHL : ("SHL" | "shl") >  | < SHR : ("SHR" | "shr") >
  |
  < CPY : ("CPY" | "cpy") >
  |
  < CMP : ("CMP" | "cmp") >
  |
  < LOD : ("LOD" | "lod") > | < STOR : ("STOR" | "stor") >
  |
  < JMP : ("JMP" | "jmp") > | < JE : ("JE" | "je") >
  |
  < JNE : ("JNE" | "jne") > | < JL : ("JL" | "jl") >
  |
  < JLE : ("JLE" | "jle") > | < JG : ("JG" | "jg") >
  |
  < JGE : ("JGE" | "jge") >
  |
  < INT : ("INT" | "int") >
  |
  < CALL : ("CALL" | "call") > | < RET : ("RET" | "ret") >
  |
  < PUSH : ("PUSH" | "push") > | < POP : ("POP" | "pop") >
  |
//directives
  < CODESEG : ("%CODE" | "%code") >
  |
  < DATASEG : ("%DATA" | "%data") >
  |
  < STACKSEG : ("%STACK" | "%stack") >
  |
  < INCLUDE : ("%INCLUDE" | "%include") >
  |
  < DEF : ("%DEF" | "%def") >
  |
  < MACRO : ("%MACRO" | "%macro") >
  |
  < ENDMACRO : ("%ENDMACRO" | "%endmacro") >
  |
//pseudoinstructions
  < DB : ("DB" | "db") >  | < DW : ("DW" | "dw") >
  |
  < RESB : ("RESB" | "resb") >  | < RESW : ("RESW" | "resw") > 
  |
  < BYTE : ("BYTE" | "byte") > 
}
TOKEN : /* IDENTIFIERS */{  < REG_INT : ( ("R" | "r") <DIGIT> ( <DIGIT> )? ) | <NAMED_REG> >
  |
  < REG_FLOAT : ("F" | "f") <DIGIT> ( <DIGIT> )? >
  |
  < IDENTIFIER :  <LETTER> ( <LETTER> | <DIGIT> )* >
  | 
  < #NAMED_REG : ("FR" | "fr" | "IR" | "ir" | "MR" | "mr" |
                  "DT" | "dt" | "UD" | "ud" | "ST" | "st" |
                  "SB" | "sb" | "SP" | "sp" | "FP" | "fp" | "IP" | "ip") >
  |   < #LETTER : [ "_", ".", "a"-"z", "A"-"Z" ] >
  |   < #DIGIT : [ "0"-"9" ] >}ASTProg Prog() : {/*@bgen(jjtree) Prog */
  ASTProg jjtn000 = new ASTProg(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Prog */
                          try {
/*@egen*/
			  (<NEWLINE>)*
	  ((Include() | Def() | Macro()) (<NEWLINE>)* )*
	  (Segment())+
	  (StackDecl())?/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	  { return jjtn000; }/*@bgen(jjtree)*/
                          } catch (Throwable jjte000) {
                            if (jjtc000) {
                              jjtree.clearNodeScope(jjtn000);
                              jjtc000 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte000 instanceof RuntimeException) {
                              throw (RuntimeException)jjte000;
                            }
                            if (jjte000 instanceof ParseException) {
                              throw (ParseException)jjte000;
                            }
                            throw (Error)jjte000;
                          } finally {
                            if (jjtc000) {
                              jjtree.closeNodeScope(jjtn000, true);
                            }
                          }
/*@egen*/
}

void Segment() : {/*@bgen(jjtree) Segment */
                   ASTSegment jjtn000 = new ASTSegment(JJTSEGMENT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Segment */
          try {
/*@egen*/
	  ( t=<CODESEG> | t=<DATASEG> ) (<NEWLINE>)+
	  { jjtn000.value = t.image.substring(1); }
	  StmtList()/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

/*
 * The stack segment is treated differently; in the executable format, it is
 * a segment, but on the source, it is just the declaration of the stack size.
*/
void StackDecl() : {/*@bgen(jjtree) StackDecl */
  ASTStackDecl jjtn000 = new ASTStackDecl(JJTSTACKDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StackDecl */
          try {
/*@egen*/
	  <STACKSEG>  ((<NEWLINE>)+)?
	  DeclaratorNonInit() Integer() ((<NEWLINE>)+ | <EOF>)/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void StmtList()       : {}
{
	  ( ( Label() (<NEWLINE>)* )? ( Stmt() | PseudoStmt() | Include() ) ((<NEWLINE>)+ | <EOF>) )*
}
void Stmt() : {/*@bgen(jjtree) Stmt */
  ASTStmt jjtn000 = new ASTStmt(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Stmt */
  try {
/*@egen*/  Opcode() ( Arg() ( "," Arg() )? )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void PseudoStmt() : {/*@bgen(jjtree) PseudoStmt */
  ASTPseudoStmt jjtn000 = new ASTPseudoStmt(JJTPSEUDOSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PseudoStmt */
  try {
/*@egen*/
  Declarator() Values()
  |
  DeclaratorNonInit() Integer()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Include() : {/*@bgen(jjtree) Include */
  ASTInclude jjtn000 = new ASTInclude(JJTINCLUDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Include */
  try {
/*@egen*/
  <INCLUDE> Str()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Def() : {/*@bgen(jjtree) Def */
  ASTDef jjtn000 = new ASTDef(JJTDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Def */
  try {
/*@egen*/
  <DEF> Id() Value()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Macro() : {/*@bgen(jjtree) Macro */
                 ASTMacro jjtn000 = new ASTMacro(JJTMACRO);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Macro */
          try {
/*@egen*/
	  <MACRO> Id()
	  StmtList()
	  <ENDMACRO> Id()/*@bgen(jjtree)*/
          } catch (Throwable jjte000) {
            if (jjtc000) {
              jjtree.clearNodeScope(jjtn000);
              jjtc000 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
              throw (RuntimeException)jjte000;
            }
            if (jjte000 instanceof ParseException) {
              throw (ParseException)jjte000;
            }
            throw (Error)jjte000;
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}
void Opcode() : {/*@bgen(jjtree) Opcode */
                  ASTOpcode jjtn000 = new ASTOpcode(JJTOPCODE);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Opcode */
  try {
/*@egen*/
  ( t=<NOP> | t=<HALT> |
    t=<INC> | t=<DEC> | t=<ADD> | t=<SUB> | t=<MUL> | t=<DIV> | t=<NEG> |
    t=<AND> | t=<OR> | t=<XOR> | t=<NOT> |
    t=<SHL> | t=<SHR> |
    t=<CPY> | t=<CMP> | t=<LOD> | t=<STOR> |
    t=<JMP> | t=<JE> | t=<JNE> | t=<JL> | t=<JLE> | t=<JG> | t=<JGE> |
    t=<INT> | t=<CALL> | t=<RET> |
    t=<PUSH> | t=<POP>
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  
  { jjtn000.value = t.image.toUpperCase(); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void Arg()       : {}
{
  Id() | Integer() | RegInt() | RegFloat() | Char() | MemRef()
}

void Declarator() : {/*@bgen(jjtree) Declarator */
                      ASTDeclarator jjtn000 = new ASTDeclarator(JJTDECLARATOR);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Declarator */
          try {
/*@egen*/
	  ( t=<DB> | t=<DW> )/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	  { jjtn000.value = t.image.toUpperCase(); }/*@bgen(jjtree)*/
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void DeclaratorNonInit() : {/*@bgen(jjtree) DeclaratorNonInit */
                             ASTDeclaratorNonInit jjtn000 = new ASTDeclaratorNonInit(JJTDECLARATORNONINIT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DeclaratorNonInit */
          try {
/*@egen*/
	  ( t=<RESB> | t=<RESW> )/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/
	  { jjtn000.value = t.image.toUpperCase(); }/*@bgen(jjtree)*/
          } finally {
            if (jjtc000) {
              jjtree.closeNodeScope(jjtn000, true);
            }
          }
/*@egen*/
}

void Values() : {/*@bgen(jjtree) Values */
  ASTValues jjtn000 = new ASTValues(JJTVALUES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Values */
  try {
/*@egen*/
  Value() ( "," Value() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Value()       : {}
{
  Integer() | Char() | Str()
}

void Label() : {/*@bgen(jjtree) Label */
                 ASTLabel jjtn000 = new ASTLabel(JJTLABEL);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Label */
  try {
/*@egen*/
  t=< IDENTIFIER > ":"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Id() : {/*@bgen(jjtree) Id */
              ASTId jjtn000 = new ASTId(JJTID);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }{/*@bgen(jjtree) Id */
  try {
/*@egen*/  t=< IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void Integer() : {/*@bgen(jjtree) Integer */
  ASTInteger jjtn000 = new ASTInteger(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Integer */
  try {
/*@egen*/  jjtn000.value = <INTEGER_LITERAL>.image/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Char() : {/*@bgen(jjtree) Char */
                ASTChar jjtn000 = new ASTChar(JJTCHAR);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Char */
  try {
/*@egen*/
  t=< CHAR_LITERAL >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Str() : {/*@bgen(jjtree) Str */
               ASTStr jjtn000 = new ASTStr(JJTSTR);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Str */
  try {
/*@egen*/
  t=< STR_LITERAL >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image.substring(1, t.image.length()-1); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RegInt() : {/*@bgen(jjtree) RegInt */
                  ASTRegInt jjtn000 = new ASTRegInt(JJTREGINT);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RegInt */
  try {
/*@egen*/
  t=<REG_INT>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image.toUpperCase(); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RegFloat() : {/*@bgen(jjtree) RegFloat */
                    ASTRegFloat jjtn000 = new ASTRegFloat(JJTREGFLOAT);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RegFloat */
  try {
/*@egen*/
  t=<REG_FLOAT>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image.toUpperCase(); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MemRef() : {/*@bgen(jjtree) MemRef */
  ASTMemRef jjtn000 = new ASTMemRef(JJTMEMREF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MemRef */
  try {
/*@egen*/
  "*" (
    ( RegInt() | "(" RegInt() ( MemOffset() )? ")" )
    |
    Id()
  ) 
  ( MemSize() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MemOffset() : {/*@bgen(jjtree) MemOffset */
                     ASTMemOffset jjtn000 = new ASTMemOffset(JJTMEMOFFSET);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1, t2; }{/*@bgen(jjtree) MemOffset */
  try {
/*@egen*/
  (t1="+" | t1="-") t2=<INTEGER_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  // Integer.parseInt does not understand prefix "plus" sign...  
  { jjtn000.value = t1.image.equals("-") ? t1.image + t2.image : t2.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void MemSize() : {/*@bgen(jjtree) MemSize */
                   ASTMemSize jjtn000 = new ASTMemSize(JJTMEMSIZE);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MemSize */
  try {
/*@egen*/
  ":" t=<BYTE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = t.image.toUpperCase(); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
